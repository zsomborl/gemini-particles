<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Particle Flow | Tracking Preview</title>
    <style>
        /* --- RESET & BASIC STYLE --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #020202; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Disables standard touch gestures */
            -webkit-user-select: none; /* iOS text selection disable */
            user-select: none;
        }
        
        /* --- OVERLAY (The "Gatekeeper") --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #111, #222);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.5s ease;
        }
        
        h1 { color: white; margin-bottom: 10px; font-weight: 300; letter-spacing: 2px; }
        p { color: #aaa; max-width: 400px; margin-bottom: 30px; line-height: 1.5; font-size: 0.9rem; }

        #start-btn {
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            border: none;
            padding: 16px 40px;
            border-radius: 50px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 210, 255, 0.3);
            transition: transform 0.2s;
            -webkit-tap-highlight-color: transparent;
        }
        #start-btn:active { transform: scale(0.95); }
        #start-btn:disabled { opacity: 0.5; cursor: wait; background: #555; }

        /* --- UI CONTROLS --- */
        #ui-layer {
            position: absolute;
            bottom: 30px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 500px;
            background: rgba(20, 20, 20, 0.75);
            backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
            padding: 15px; border-radius: 24px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: none; z-index: 100;
        }

        .btn-row { 
            display: flex; overflow-x: auto; gap: 8px; padding-bottom: 5px; margin-bottom: 10px; 
            -webkit-overflow-scrolling: touch;
        }
        .btn-row::-webkit-scrollbar { display: none; } 
        
        button.shape-btn {
            background: rgba(255, 255, 255, 0.15); border: none; color: white;
            padding: 12px 18px; border-radius: 12px; font-size: 0.85rem; white-space: nowrap;
            transition: background 0.2s; -webkit-tap-highlight-color: transparent;
        }
        button.shape-btn.active { background: #00d2ff; color: #000; font-weight: bold; }

        .status-row { display: flex; justify-content: space-between; align-items: center; color: #888; font-size: 0.75rem; }
        .indicator { display: flex; align-items: center; gap: 6px; }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: #555; transition: 0.3s; }
        .dot.active { background: #00ff88; box-shadow: 0 0 6px #00ff88; }

        /* --- NEW: PREVIEW WINDOW --- */
        #preview-container {
            position: absolute;
            bottom: 140px; /* Above the main UI layer */
            right: 20px;
            width: 120px; /* Small size */
            height: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            z-index: 90;
            display: none; /* Hidden until active */
            /* Mirror the preview so movement feels natural */
            transform: scaleX(-1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        #preview-canvas {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
        }

        /* --- DEBUG/ERROR LOG --- */
        #debug-log {
            color: #ff5e57; font-family: monospace; font-size: 0.8rem; margin-top: 20px;
            background: rgba(0,0,0,0.8); padding: 15px; border-radius: 8px;
            display: none; text-align: left; max-width: 90%; word-wrap: break-word;
        }

        /* --- HIDDEN INPUT VIDEO --- */
        #input-video { position: absolute; top: 0; left: 0; width: 1px; height: 1px; opacity: 0; pointer-events: none; z-index: -1; }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>PARTICLE AI</h1>
        <p>Interactive 3D particles controlled by your hand tension.<br><br>iOS/Android Compatible.</p>
        <button id="start-btn">TAP TO START</button>
        <div id="debug-log"></div>
    </div>

    <div id="preview-container">
        <canvas id="preview-canvas"></canvas>
    </div>

    <div id="ui-layer">
        <div class="btn-row">
            <button class="shape-btn active" onclick="app.setShape('heart')">Heart</button>
            <button class="shape-btn" onclick="app.setShape('sphere')">Sphere</button>
            <button class="shape-btn" onclick="app.setShape('spiral')">Galaxy</button>
            <button class="shape-btn" onclick="app.setShape('saturn')">Saturn</button>
            <button class="shape-btn" onclick="app.setShape('flower')">Lotus</button>
            <button class="shape-btn" onclick="app.setShape('fireworks')">Burst</button>
        </div>
        <div class="status-row">
            <div class="indicator">
                <div class="dot" id="cam-dot"></div> <span>Camera</span>
            </div>
            <div class="indicator">
                <div class="dot" id="hand-dot"></div> <span>Hand Detect</span>
            </div>
        </div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        class ParticleApp {
            constructor() {
                this.isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                this.container = document.body;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                // State
                this.tension = 0; 
                this.targetScale = 1.0;
                this.currentScale = 1.0;
                this.shapeType = 'heart';
                this.isPlaying = false;
                
                // Config
                this.particleCount = this.isMobile ? 2800 : 7000; 
                this.throttleFrame = 0;
                this.throttleLimit = this.isMobile ? 3 : 0; 

                // Preview setup
                this.previewCanvas = document.getElementById('preview-canvas');
                this.previewCtx = this.previewCanvas.getContext('2d');

                this.initThree();
                this.initParticles();
                this.setupUI();
            }

            // --- THREE.JS SETUP ---
            initThree() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x020202, 0.02);

                this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
                this.camera.position.z = this.isMobile ? 38 : 30;

                this.renderer = new THREE.WebGLRenderer({ antialias: !this.isMobile, alpha: true });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
                this.container.appendChild(this.renderer.domElement);

                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.camera.aspect = this.width / this.height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.width, this.height);
                });
            }

            // --- PARTICLE SYSTEM ---
            initParticles() {
                const geometry = new THREE.BufferGeometry();
                const posArray = new Float32Array(this.particleCount * 3);
                const targetArray = new Float32Array(this.particleCount * 3);

                for(let i=0; i<this.particleCount*3; i++) {
                    posArray[i] = (Math.random()-0.5) * 100;
                    targetArray[i] = posArray[i];
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                this.targetPositions = targetArray;

                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                const material = new THREE.PointsMaterial({
                    size: this.isMobile ? 0.9 : 0.6, map: texture, transparent: true,
                    opacity: 0.8, color: 0x00d2ff, blending: THREE.AdditiveBlending, depthWrite: false
                });

                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
                this.setShape('heart');
            }

            // --- SHAPE MATHS ---
            setShape(type) {
                this.shapeType = type;
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                const clickedBtn = [...document.querySelectorAll('.shape-btn')].find(b => b.innerText.toLowerCase().includes(type.substring(0,3)));
                if(clickedBtn) clickedBtn.classList.add('active');

                for (let i = 0; i < this.particleCount; i++) {
                    const ix = i * 3;
                    const pt = this.getPointForShape(type, i);
                    this.targetPositions[ix] = pt.x; this.targetPositions[ix+1] = pt.y; this.targetPositions[ix+2] = pt.z;
                }
            }

            getPointForShape(type, i) {
                const phi = Math.acos(-1 + (2 * i) / this.particleCount);
                const theta = Math.sqrt(this.particleCount * Math.PI) * phi;
                
                if (type === 'heart') {
                    const t = (i / this.particleCount) * Math.PI * 20;
                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    return { x: x*0.5, y: y*0.5, z: (Math.random()-0.5)*5 };
                } 
                else if (type === 'saturn') {
                    if (i < this.particleCount * 0.7) {
                        const r = 8;
                        return { x: r*Math.cos(theta)*Math.sin(phi), y: r*Math.sin(theta)*Math.sin(phi), z: r*Math.cos(phi) };
                    } else {
                        const angle = i * 0.1; const r = 12 + Math.random() * 6;
                        return { x: Math.cos(angle)*r, y: (Math.random()-0.5)*0.5, z: Math.sin(angle)*r };
                    }
                }
                else if (type === 'spiral') {
                     const t = i * 0.02;
                     return { x: t*Math.cos(t*3), y: (i/this.particleCount)*20-10, z: t*Math.sin(t*3) };
                }
                else if (type === 'fireworks') {
                    const t2 = Math.random()*Math.PI*2; const p2 = Math.acos((Math.random()*2)-1); const r = Math.random()*18;
                    return { x: r*Math.sin(p2)*Math.cos(t2), y: r*Math.sin(p2)*Math.sin(t2), z: r*Math.cos(p2) };
                }
                else if (type === 'flower') {
                    const angle = i * 137.5 * (Math.PI/180); const r = 0.6 * Math.sqrt(i);
                    return { x: r*Math.cos(angle)*0.6, y: (r*r*0.05)-6, z: r*Math.sin(angle)*0.6 };
                }
                const r = 10;
                return { x: r*Math.cos(theta)*Math.sin(phi), y: r*Math.sin(theta)*Math.sin(phi), z: r*Math.cos(phi) };
            }

            // --- CAMERA & AI ---
            async startCamera() {
                this.videoElement = document.getElementById('input-video');
                const debug = document.getElementById('debug-log');
                const startBtn = document.getElementById('start-btn');
                startBtn.innerText = "INITIALIZING..."; startBtn.disabled = true;

                try {
                    this.hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
                    this.hands.setOptions({
                        maxNumHands: 1, modelComplexity: this.isMobile ? 0 : 1,
                        minDetectionConfidence: 0.5, minTrackingConfidence: 0.5
                    });
                    this.hands.onResults(this.onHandsResult.bind(this));
                } catch (e) {
                    debug.style.display = 'block'; debug.innerText = "AI Load Error: " + e.message; return;
                }

                const constraints = { audio: false, video: { facingMode: "user", width: { ideal: this.isMobile ? 480 : 640 }, height: { ideal: this.isMobile ? 640 : 480 } } };

                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    this.videoElement.srcObject = stream;
                    
                    this.videoElement.onloadedmetadata = () => {
                        this.videoElement.play().then(() => {
                            this.isPlaying = true;
                            // Set preview canvas dimensions to match video source
                            this.previewCanvas.width = this.videoElement.videoWidth;
                            this.previewCanvas.height = this.videoElement.videoHeight;

                            document.getElementById('overlay').style.opacity = '0';
                            setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);
                            document.getElementById('ui-layer').style.display = 'block';
                            document.getElementById('preview-container').style.display = 'block'; // Show preview
                            document.getElementById('cam-dot').classList.add('active');
                            this.animate();
                        }).catch(e => { debug.style.display = 'block'; debug.innerText = "Play Error: " + e.message; });
                    };
                } catch (err) {
                    debug.style.display = 'block'; debug.innerHTML = `<strong>Camera Error:</strong> ${err.name}<br>Check permissions. iOS users must use Safari.`;
                    startBtn.innerText = "RETRY"; startBtn.disabled = false;
                }
            }

            onHandsResult(results) {
                const handDot = document.getElementById('hand-dot');
                
                // --- Draw Preview ---
                // 1. Clear canvas
                this.previewCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
                // 2. Draw video frame
                this.previewCtx.drawImage(this.videoElement, 0, 0, this.previewCanvas.width, this.previewCanvas.height);
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handDot.classList.add('active');
                    const lm = results.multiHandLandmarks[0];
                    
                    // 3. Draw Hand Landmarks on preview
                    drawConnectors(this.previewCtx, lm, HAND_CONNECTIONS, {color: '#00d2ff', lineWidth: 2});
                    drawLandmarks(this.previewCtx, lm, {color: '#ff0055', lineWidth: 1, radius: 2});

                    // Calculate Tension
                    const wrist = lm[0]; const middleTip = lm[12];
                    const d = Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2));
                    let t = 1 - ((d - 0.2) / 0.3);
                    t = Math.max(0, Math.min(1, t));
                    this.tension += (t - this.tension) * 0.15;
                } else {
                    handDot.classList.remove('active');
                    this.tension *= 0.95;
                }
            }

            animate() {
                requestAnimationFrame(this.animate.bind(this));

                this.throttleFrame++;
                if (this.throttleFrame > this.throttleLimit && this.videoElement.readyState >= 2) {
                    this.throttleFrame = 0;
                    this.hands.send({image: this.videoElement}).catch(() => {});
                }

                const scaleGoal = 1.0 - (this.tension * 0.6);
                this.currentScale += (scaleGoal - this.currentScale) * 0.1;

                this.particles.rotation.y += 0.003;
                
                if (this.tension > 0.3) {
                    this.particles.rotation.z = (Math.random()-0.5) * 0.15 * this.tension;
                    this.particles.rotation.x = (Math.random()-0.5) * 0.15 * this.tension;
                } else {
                    this.particles.rotation.z *= 0.9; this.particles.rotation.x *= 0.9;
                }

                const positions = this.particles.geometry.attributes.position.array;
                for(let i=0; i < this.particleCount; i++) {
                    const i3 = i*3;
                    const tx = this.targetPositions[i3] * this.currentScale;
                    const ty = this.targetPositions[i3+1] * this.currentScale;
                    const tz = this.targetPositions[i3+2] * this.currentScale;
                    const speed = this.tension > 0.6 ? 0.25 : 0.06;
                    positions[i3] += (tx - positions[i3]) * speed;
                    positions[i3+1] += (ty - positions[i3+1]) * speed;
                    positions[i3+2] += (tz - positions[i3+2]) * speed;
                }
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.renderer.render(this.scene, this.camera);
            }

            setupUI() {
                const btn = document.getElementById('start-btn');
                const triggerStart = (e) => { e.preventDefault(); this.startCamera(); btn.removeEventListener('click', triggerStart); btn.removeEventListener('touchstart', triggerStart); };
                btn.addEventListener('click', triggerStart); btn.addEventListener('touchstart', triggerStart, {passive: false});
            }
        }

        const app = new ParticleApp();
    </script>
</body>
</html>
