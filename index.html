<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Particle Flow | Mobile AI</title>
    <style>
        /* --- RESET & BASIC STYLE --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            touch-action: none; /* Disables standard touch gestures (scroll/zoom) */
            -webkit-user-select: none; /* iOS safari text selection disable */
        }
        
        /* --- START OVERLAY (The "Gatekeeper") --- */
        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #111, #222);
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
            transition: opacity 0.5s ease;
        }
        
        h1 { color: white; margin-bottom: 10px; font-weight: 300; letter-spacing: 2px; }
        p { color: #aaa; max-width: 400px; margin-bottom: 30px; line-height: 1.5; }

        /* The "Giant" Start Button - Apple requires a user gesture */
        #start-btn {
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            border: none;
            padding: 15px 40px;
            border-radius: 50px;
            color: white;
            font-size: 1.1rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            box-shadow: 0 10px 20px rgba(0, 210, 255, 0.3);
            transition: transform 0.2s, opacity 0.2s;
        }
        #start-btn:active { transform: scale(0.95); }
        #start-btn:disabled { opacity: 0.5; cursor: wait; }

        /* --- UI CONTROLS (Glassmorphism) --- */
        #ui-layer {
            position: absolute;
            bottom: 30px; /* Moved to bottom for easier thumb reach on mobile */
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 500px;
            background: rgba(20, 20, 20, 0.8);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px); /* Safari fix */
            padding: 15px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: none; /* Hidden until camera starts */
            z-index: 100;
        }

        .btn-row { display: flex; overflow-x: auto; gap: 8px; padding-bottom: 5px; margin-bottom: 10px; }
        /* Hide scrollbar */
        .btn-row::-webkit-scrollbar { display: none; } 
        
        button.shape-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 10px 16px;
            border-radius: 12px;
            font-size: 0.85rem;
            white-space: nowrap;
            transition: background 0.2s;
        }
        button.shape-btn.active { background: #00d2ff; color: #000; font-weight: bold; }

        .status-row { display: flex; justify-content: space-between; align-items: center; color: #888; font-size: 0.75rem; }
        .indicator { display: flex; align-items: center; gap: 6px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #555; transition: 0.3s; }
        .dot.active { background: #00ff88; box-shadow: 0 0 8px #00ff88; }

        /* --- DEBUG/ERROR LOG (Visible on phone) --- */
        #debug-log {
            color: #ff5e57;
            font-family: monospace;
            font-size: 0.8rem;
            margin-top: 20px;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 8px;
            display: none;
        }

        /* --- HIDDEN VIDEO --- */
        /* playsinline is MANDATORY for iOS Safari */
        #input-video {
            position: absolute; top: 0; left: 0;
            width: 1px; height: 1px; opacity: 0; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="overlay">
        <h1>PARTICLE AI</h1>
        <p>Interactive 3D particles controlled by your hand tension.<br><br><b>Instructions:</b><br>Show hand to camera.<br>Open hand = Expand.<br>Fist = Collapse.</p>
        <button id="start-btn">TAP TO START</button>
        <div id="debug-log"></div>
    </div>

    <div id="ui-layer">
        <div class="btn-row">
            <button class="shape-btn active" onclick="app.setShape('heart')">Heart</button>
            <button class="shape-btn" onclick="app.setShape('sphere')">Sphere</button>
            <button class="shape-btn" onclick="app.setShape('spiral')">Galaxy</button>
            <button class="shape-btn" onclick="app.setShape('saturn')">Saturn</button>
            <button class="shape-btn" onclick="app.setShape('flower')">Lotus</button>
            <button class="shape-btn" onclick="app.setShape('fireworks')">Burst</button>
        </div>
        <div class="status-row">
            <div class="indicator">
                <div class="dot" id="cam-dot"></div> <span>Camera</span>
            </div>
            <div class="indicator">
                <div class="dot" id="hand-dot"></div> <span>Hand Detect</span>
            </div>
            <div id="fps-counter">0 FPS</div>
        </div>
    </div>

    <video id="input-video" playsinline webkit-playsinline muted autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        class ParticleApp {
            constructor() {
                this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                this.container = document.body;
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                // State
                this.tension = 0; // 0 (open) to 1 (fist)
                this.targetScale = 1.0;
                this.currentScale = 1.0;
                this.shapeType = 'heart';
                this.isPlaying = false;
                
                // Config
                this.particleCount = this.isMobile ? 2500 : 6000; // Performance optimization
                this.throttleFrame = 0;
                this.throttleLimit = this.isMobile ? 2 : 0; // Skip every 2nd frame on mobile AI

                this.initThree();
                this.initParticles();
                this.setupUI();
            }

            // --- 1. THREE.JS SETUP ---
            initThree() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

                this.camera = new THREE.PerspectiveCamera(75, this.width / this.height, 0.1, 1000);
                this.camera.position.z = this.isMobile ? 35 : 30; // Further back on mobile

                this.renderer = new THREE.WebGLRenderer({ antialias: !this.isMobile, powerPreference: "high-performance" });
                this.renderer.setSize(this.width, this.height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x for Retina performance
                this.container.appendChild(this.renderer.domElement);

                // Resize Handler
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.camera.aspect = this.width / this.height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(this.width, this.height);
                });
            }

            // --- 2. PARTICLE SYSTEM ---
            initParticles() {
                const geometry = new THREE.BufferGeometry();
                const posArray = new Float32Array(this.particleCount * 3);
                const targetArray = new Float32Array(this.particleCount * 3); // Where they want to go

                // Init Random
                for(let i=0; i<this.particleCount*3; i++) {
                    posArray[i] = (Math.random()-0.5) * 100;
                    targetArray[i] = posArray[i];
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                this.targetPositions = targetArray;

                // Create Glow Texture
                const canvas = document.createElement('canvas');
                canvas.width = 32; canvas.height = 32;
                const ctx = canvas.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad;
                ctx.fillRect(0,0,32,32);
                const texture = new THREE.Texture(canvas);
                texture.needsUpdate = true;

                const material = new THREE.PointsMaterial({
                    size: this.isMobile ? 0.9 : 0.6,
                    map: texture,
                    transparent: true,
                    opacity: 0.8,
                    color: 0x00d2ff,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
                
                // Set Initial Shape
                this.setShape('heart');
            }

            // --- 3. SHAPE MATHS ---
            setShape(type) {
                this.shapeType = type;
                
                // UI Highlight
                document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
                const clickedBtn = [...document.querySelectorAll('.shape-btn')].find(b => b.innerText.toLowerCase().includes(type.substring(0,3)));
                if(clickedBtn) clickedBtn.classList.add('active');

                // Recalculate Targets
                for (let i = 0; i < this.particleCount; i++) {
                    const ix = i * 3;
                    const pt = this.getPointForShape(type, i);
                    this.targetPositions[ix] = pt.x;
                    this.targetPositions[ix+1] = pt.y;
                    this.targetPositions[ix+2] = pt.z;
                }
            }

            getPointForShape(type, i) {
                // Sphere (Default fallback)
                const phi = Math.acos(-1 + (2 * i) / this.particleCount);
                const theta = Math.sqrt(this.particleCount * Math.PI) * phi;
                let x, y, z;

                if (type === 'heart') {
                    const t = (i / this.particleCount) * Math.PI * 20;
                    x = 16 * Math.pow(Math.sin(t), 3);
                    y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                    z = (Math.random() - 0.5) * 5;
                    return { x: x*0.5, y: y*0.5, z: z };
                } 
                else if (type === 'saturn') {
                    // 70% Planet, 30% Rings
                    if (i < this.particleCount * 0.7) {
                        const r = 8;
                        x = r * Math.cos(theta) * Math.sin(phi);
                        y = r * Math.sin(theta) * Math.sin(phi);
                        z = r * Math.cos(phi);
                    } else {
                        const angle = i * 0.1;
                        const r = 12 + Math.random() * 6;
                        x = Math.cos(angle) * r;
                        y = (Math.random() - 0.5) * 0.5;
                        z = Math.sin(angle) * r;
                    }
                    return { x, y, z };
                }
                else if (type === 'spiral') {
                     const t = i * 0.02;
                     x = t * Math.cos(t * 3);
                     y = (i / this.particleCount) * 20 - 10;
                     z = t * Math.sin(t * 3);
                     return { x, y, z };
                }
                else if (type === 'fireworks') {
                    const t2 = Math.random() * Math.PI * 2;
                    const p2 = Math.acos((Math.random() * 2) - 1);
                    const r = Math.random() * 18;
                    return {
                        x: r * Math.sin(p2) * Math.cos(t2),
                        y: r * Math.sin(p2) * Math.sin(t2),
                        z: r * Math.cos(p2)
                    };
                }
                else if (type === 'flower') {
                    const angle = i * 137.5 * (Math.PI/180); // Golden angle
                    const r = 0.6 * Math.sqrt(i);
                    return {
                        x: r * Math.cos(angle) * 0.6,
                        y: (r * r * 0.05) - 6,
                        z: r * Math.sin(angle) * 0.6
                    };
                }
                
                // Sphere
                const r = 10;
                x = r * Math.cos(theta) * Math.sin(phi);
                y = r * Math.sin(theta) * Math.sin(phi);
                z = r * Math.cos(phi);
                return { x, y, z };
            }

            // --- 4. CAMERA & AI HANDLING ---
            async startCamera() {
                const video = document.getElementById('input-video');
                const debug = document.getElementById('debug-log');
                const startBtn = document.getElementById('start-btn');

                startBtn.innerText = "STARTING AI...";
                startBtn.disabled = true;

                // 4a. Initialize MediaPipe
                try {
                    this.hands = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                    });
                    
                    this.hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: this.isMobile ? 0 : 1, // 0 is faster, 1 is accurate
                        minDetectionConfidence: 0.5,
                        minTrackingConfidence: 0.5
                    });
                    
                    this.hands.onResults(this.onHandsResult.bind(this));
                } catch (e) {
                    debug.style.display = 'block';
                    debug.innerText = "Error Loading AI: " + e.message;
                    return;
                }

                // 4b. Get Native Camera Stream
                // Mobile resolution tip: 640x480 is standard. Higher = slower.
                const constraints = {
                    audio: false,
                    video: {
                        facingMode: "user",
                        width: { ideal: this.isMobile ? 480 : 640 },
                        height: { ideal: this.isMobile ? 640 : 480 }
                    }
                };

                try {
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    video.srcObject = stream;
                    
                    // Wait for video to be ready (Critical for iOS)
                    video.onloadedmetadata = () => {
                        video.play();
                        this.isPlaying = true;
                        
                        // Update UI
                        document.getElementById('overlay').style.opacity = '0';
                        setTimeout(() => document.getElementById('overlay').style.display = 'none', 500);
                        document.getElementById('ui-layer').style.display = 'block';
                        document.getElementById('cam-dot').classList.add('active');
                        
                        this.animate(); // Start Loop
                    };
                } catch (err) {
                    debug.style.display = 'block';
                    debug.innerText = "CAMERA ERROR: " + err.name + " - " + err.message + "\nCheck browser permissions.";
                    startBtn.innerText = "RETRY";
                    startBtn.disabled = false;
                }
            }

            onHandsResult(results) {
                const handDot = document.getElementById('hand-dot');
                
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    handDot.classList.add('active');
                    
                    const lm = results.multiHandLandmarks[0];
                    const wrist = lm[0];
                    const indexTip = lm[8];
                    const thumbTip = lm[4];
                    const middleTip = lm[12];
                    
                    // Calculate "Tension"
                    // We measure distance from Wrist to Middle Finger Tip
                    // Normalized coords [0,1]. 
                    // Open hand ~ 0.5 distance. Closed fist ~ 0.2 distance.
                    
                    const d = Math.sqrt(
                        Math.pow(middleTip.x - wrist.x, 2) + 
                        Math.pow(middleTip.y - wrist.y, 2)
                    );

                    // Map 0.2(closed)..0.5(open) to 1..0
                    let t = 1 - ((d - 0.2) / 0.3);
                    t = Math.max(0, Math.min(1, t)); // Clamp 0-1
                    
                    // Smooth lerp for jitter reduction
                    this.tension += (t - this.tension) * 0.1;
                    
                } else {
                    handDot.classList.remove('active');
                    this.tension *= 0.95; // Decay
                }
            }

            // --- 5. ANIMATION LOOP ---
            animate() {
                requestAnimationFrame(this.animate.bind(this));

                const video = document.getElementById('input-video');

                // 5a. AI Throttling (Don't run every frame on mobile)
                this.throttleFrame++;
                if (this.throttleFrame > this.throttleLimit && video.readyState === 4) {
                    this.throttleFrame = 0;
                    this.hands.send({image: video}).catch(e => {}); // Ignore dropped frames
                }

                // 5b. Physics
                // Target Scale based on tension: 1.0 (relaxed) -> 0.4 (tensed)
                const scaleGoal = 1.0 - (this.tension * 0.6);
                this.currentScale += (scaleGoal - this.currentScale) * 0.05;

                // Rotation
                this.particles.rotation.y += 0.002;
                if (this.tension > 0.3) {
                    // Shake effect
                    this.particles.rotation.z = (Math.random()-0.5) * 0.1 * this.tension;
                    this.particles.rotation.x = (Math.random()-0.5) * 0.1 * this.tension;
                } else {
                    this.particles.rotation.z *= 0.9;
                    this.particles.rotation.x *= 0.9;
                }

                // 5c. Vertex Updates
                const positions = this.particles.geometry.attributes.position.array;
                const count = this.particleCount;
                
                // Unroll loop logic
                for(let i=0; i < count; i++) {
                    const i3 = i*3;
                    
                    const tx = this.targetPositions[i3] * this.currentScale;
                    const ty = this.targetPositions[i3+1] * this.currentScale;
                    const tz = this.targetPositions[i3+2] * this.currentScale;

                    // Speed increases with tension
                    const speed = this.tension > 0.6 ? 0.2 : 0.04;
                    
                    positions[i3] += (tx - positions[i3]) * speed;
                    positions[i3+1] += (ty - positions[i3+1]) * speed;
                    positions[i3+2] += (tz - positions[i3+2]) * speed;
                }
                
                this.particles.geometry.attributes.position.needsUpdate = true;
                this.renderer.render(this.scene, this.camera);
            }

            setupUI() {
                document.getElementById('start-btn').addEventListener('click', () => {
                    this.startCamera();
                });
                
                // Mobile Touch Support
                document.getElementById('start-btn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.startCamera();
                }, {passive: false});
            }
        }

        // Initialize
        const app = new ParticleApp();
    </script>
</body>
</html>
