<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Particle Core | INSTANT</title>
    <style>
        /* --- CORE --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: monospace; touch-action: none; }

        /* --- UI OVERLAY --- */
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px;
        }

        /* --- START BUTTON (Centered) --- */
        #start-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: auto; text-align: center; z-index: 100;
        }

        #engage-btn {
            background: rgba(0, 0, 0, 0.8); color: #00d2ff;
            border: 2px solid #00d2ff; padding: 20px 50px;
            font-size: 1.2rem; font-weight: bold; letter-spacing: 2px;
            cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.3);
            transition: 0.3s;
        }
        #engage-btn:hover { background: #00d2ff; color: #000; box-shadow: 0 0 50px rgba(0, 210, 255, 0.6); }

        /* --- PREVIEW WINDOW (Top Right) --- */
        #preview-card {
            position: absolute; top: 20px; right: 20px;
            width: 120px; height: 160px;
            background: #111; border: 2px solid #333;
            transform: scaleX(-1); /* Mirror Mode */
            pointer-events: auto; display: none; /* Hidden until active */
        }
        #preview-canvas { width: 100%; height: 100%; object-fit: cover; }

        /* --- BOTTOM CONTROLS --- */
        #controls {
            display: flex; justify-content: center; gap: 10px; pointer-events: auto; width: 100%;
        }
        button.shape-btn {
            background: rgba(20,20,20,0.8); border: 1px solid #444; color: #888;
            padding: 10px 20px; border-radius: 4px; font-weight: bold; cursor: pointer;
        }
        button.shape-btn.active { border-color: #00d2ff; color: #fff; background: rgba(0,210,255,0.2); }

        /* --- STATS --- */
        #stats { color: #555; position: absolute; top: 20px; left: 20px; }
        .active-stat { color: #00d2ff; }

        #video-source { display: none; }
    </style>
</head>
<body>

    <div id="canvas-container" style="position: absolute; inset: 0; z-index: 0;"></div>

    <div id="ui-layer">
        <div id="stats">
            STATUS: <span id="status-text">IDLE MODE</span><br>
            TENSION: <span id="tension-text">0</span>%
        </div>

        <div id="start-container">
            <button id="engage-btn">ACTIVATE CAMERA</button>
            <div style="margin-top:10px; color:#666; font-size:0.8rem;">(Particles are active in background)</div>
        </div>

        <div id="preview-card"><canvas id="preview-canvas"></canvas></div>

        <div id="controls">
            <button class="shape-btn active" onclick="setShape('jupiter')">JUPITER</button>
            <button class="shape-btn" onclick="setShape('dna')">DNA</button>
            <button class="shape-btn" onclick="setShape('saturn')">SATURN</button>
            <button class="shape-btn" onclick="setShape('galaxy')">GALAXY</button>
        </div>
    </div>

    <video id="video-source" playsinline webkit-playsinline muted autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        // --- 1. CONFIGURATION ---
        const isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
        const PARTICLE_COUNT = isMobile ? 4000 : 12000;
        let currentState = 'jupiter';
        
        // Hand State (Default to 0 tension = Assembled)
        const handState = { tension: 0.0, tiltZ: 0, panX: 0, panY: 0, detected: false };

        // --- 2. THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 40; // Default view distance

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 3. PARTICLE SYSTEM ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Shape
        const scatterPositions = new Float32Array(PARTICLE_COUNT * 3); // Explosion
        const baseColors = new Float32Array(PARTICLE_COUNT * 3);

        // --- INITIALIZE PARTICLES (FORCE VISIBILITY) ---
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const i3 = i*3;
            // Set initial position to random sphere (Visible immediately)
            const r = 20; 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3+2] = r * Math.cos(phi);
            
            // Set Scatter Positions (Far away)
            const sr = 100 + Math.random() * 100;
            scatterPositions[i3] = sr * Math.sin(phi) * Math.cos(theta);
            scatterPositions[i3+1] = sr * Math.sin(phi) * Math.sin(theta);
            scatterPositions[i3+2] = sr * Math.cos(phi);

            // Set Color to White initially
            colors[i3] = 1; colors[i3+1] = 1; colors[i3+2] = 1;
            baseColors[i3] = 1; baseColors[i3+1] = 1; baseColors[i3+2] = 1;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Texture
        const getTexture = () => {
            const c = document.createElement('canvas'); c.width=32; c.height=32;
            const ctx = c.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0,16,16,16);
            g.addColorStop(0,'rgba(255,255,255,1)');
            g.addColorStop(0.2,'rgba(255,255,255,0.8)');
            g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
            return new THREE.Texture(c);
        };
        const material = new THREE.PointsMaterial({
            size: isMobile ? 1.0 : 0.6, map: getTexture(), vertexColors: true, 
            transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. SHAPE GENERATION ---
        function setP(idx, x, y, z, r, g, b) {
            if(idx >= PARTICLE_COUNT) return;
            const i3 = idx*3;
            targetPositions[i3] = x; targetPositions[i3+1] = y; targetPositions[i3+2] = z;
            baseColors[i3] = r; baseColors[i3+1] = g; baseColors[i3+2] = b;
        }

        window.setShape = (type) => {
            currentState = type;
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            const btn = [...document.querySelectorAll('.shape-btn')].find(b => b.innerText.toLowerCase().includes(type));
            if(btn) btn.classList.add('active');

            let pIdx = 0;
            const p = PARTICLE_COUNT;

            if (type === 'dna') {
                const height = 60; const radius = 8; const turns = 5; const steps = Math.floor(p / 20);
                for(let i=0; i<steps; i++) {
                    const t = i/steps; const angle = t * Math.PI * 2 * turns; const y = t*height - height/2;
                    // Strand A
                    setP(pIdx++, Math.cos(angle)*radius, y, Math.sin(angle)*radius, 0, 0.8, 1);
                    setP(pIdx++, Math.cos(angle)*radius+0.5, y, Math.sin(angle)*radius, 0, 1, 1);
                    // Strand B
                    setP(pIdx++, Math.cos(angle+Math.PI)*radius, y, Math.sin(angle+Math.PI)*radius, 1, 0, 0.5);
                    setP(pIdx++, Math.cos(angle+Math.PI)*radius+0.5, y, Math.sin(angle+Math.PI)*radius, 1, 0.2, 0.6);
                    // Rungs
                    for(let k=0; k<16; k++) {
                        const l = k/16;
                        const rx = Math.cos(angle)*radius*(1-l) + Math.cos(angle+Math.PI)*radius*l;
                        const rz = Math.sin(angle)*radius*(1-l) + Math.sin(angle+Math.PI)*radius*l;
                        setP(pIdx++, rx, y, rz, 0.5, 0.5, 0.8);
                    }
                }
            } else if (type === 'jupiter') {
                for(let i=0; i<p; i++) {
                    const phi = Math.acos(-1 + (2*i)/p); const theta = Math.sqrt(p*Math.PI)*phi;
                    const r = 15;
                    let x = r*Math.cos(theta)*Math.sin(phi); let y = r*Math.sin(theta)*Math.sin(phi)*0.9; let z = r*Math.cos(phi);
                    const band = Math.sin(y*2.0);
                    let cr=0.8, cg=0.7, cb=0.6;
                    if(band > 0.5) { cr=0.9; cg=0.8; cb=0.8; }
                    else if(band < -0.5) { cr=0.6; cg=0.3; cb=0.2; }
                    if(x>5 && x<10 && y>-5 && y<-2 && z>0) { cr=1; cg=0.1; cb=0.1; }
                    setP(i, x,y,z, cr,cg,cb);
                }
            } else if (type === 'saturn') {
                 const pl = Math.floor(p*0.4);
                 for(let i=0; i<p; i++) {
                     let x,y,z,cr,cg,cb;
                     if(i<pl) {
                         const phi = Math.acos(-1 + (2*i)/pl); const theta = Math.sqrt(pl*Math.PI)*phi;
                         x=10*Math.cos(theta)*Math.sin(phi); y=10*Math.sin(theta)*Math.sin(phi)*0.85; z=10*Math.cos(phi);
                         cr=0.9; cg=0.8; cb=0.6;
                     } else {
                         const ang = Math.random()*Math.PI*2; const dist = 14 + Math.random()*15;
                         x=Math.cos(ang)*dist; z=Math.sin(ang)*dist; y=(Math.random()-0.5)*0.5;
                         cr=0.7; cg=0.7; cb=0.6;
                     }
                     setP(i, x,y,z, cr,cg,cb);
                 }
            } else if (type === 'galaxy') {
                for(let i=0; i<p; i++) {
                    const ang = i*0.1; const dist = Math.pow(Math.random(), 2) * 50;
                    const arms = 3; const offset = (i%arms)*(Math.PI*2/arms);
                    const angle = dist*0.2 + offset;
                    let x=Math.cos(angle)*dist; let z=Math.sin(angle)*dist; let y=(Math.random()-0.5)*(6-dist*0.1);
                    let c = 1 - (dist/50);
                    setP(i, x,y,z, 0.2+c*0.8, 0.1+c*0.5, 0.5+c*0.5);
                }
            }
            // Cleanup
            for(let i=pIdx; i<p; i++) setP(i, 0,0,0, 0,0,0);
        };
        // INIT SHAPE
        setShape('jupiter');

        // --- 5. ANIMATION LOOP ---
        const clock = new THREE.Clock();
        const baseZ = isMobile ? 50 : 40;

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;

            // --- MOVEMENT LOGIC ---
            // Idle Rotation
            if(!handState.detected) {
                particles.rotation.y += 0.002;
            }

            // Exaggerated Hand Tracking (Mirror Mode: Left Hand = Left Rotation)
            const rotYTarget = handState.panX * -3.0; // Negative X for mirror feel
            const rotXTarget = handState.panY * 3.0;
            const rotZTarget = handState.tiltZ * 2.0;

            particles.rotation.y += (rotYTarget - particles.rotation.y) * 0.1;
            particles.rotation.x += (rotXTarget - particles.rotation.x) * 0.1;
            particles.rotation.z += (rotZTarget - particles.rotation.z) * 0.1;

            // --- ZOOM / DISPERSION ---
            // Tension 0 = Assemble (Zoom In). Tension 1 = Disperse (Zoom Out)
            const disp = handState.tension; 
            
            // Zoom: 0% -> Z=40, 100% -> Z=120
            const targetZ = baseZ + (disp * 100); 
            camera.position.z += (targetZ - camera.position.z) * 0.1;

            for(let i=0; i<PARTICLE_COUNT; i++) {
                const i3 = i*3;
                
                // Mix shape vs scatter
                // Using disp^4 for very snappy explosion only when fist is tight
                const mix = Math.pow(disp, 4); 
                
                const tx = targetPositions[i3] * (1-mix) + scatterPositions[i3] * mix;
                const ty = targetPositions[i3+1] * (1-mix) + scatterPositions[i3+1] * mix;
                const tz = targetPositions[i3+2] * (1-mix) + scatterPositions[i3+2] * mix;

                const speed = 0.1 + (disp * 0.2); // Fast when dispersing

                pos[i3] += (tx - pos[i3]) * speed;
                pos[i3+1] += (ty - pos[i3+1]) * speed;
                pos[i3+2] += (tz - pos[i3+2]) * speed;

                // Color Flash
                const flash = disp > 0.8 ? 1.0 : 0;
                col[i3] = Math.min(1, baseColors[i3] + flash);
                col[i3+1] = Math.min(1, baseColors[i3+1] + flash);
                col[i3+2] = Math.min(1, baseColors[i3+2] + flash);
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            renderer.render(scene, camera);
        }
        // START ANIMATION IMMEDIATELY
        animate();

        // --- 6. TRACKING LOGIC ---
        const engageBtn = document.getElementById('engage-btn');
        const startContainer = document.getElementById('start-container');
        const previewCard = document.getElementById('preview-card');
        const previewCanvas = document.getElementById('preview-canvas');
        const previewCtx = previewCanvas.getContext('2d');
        const video = document.getElementById('video-source');
        const statusText = document.getElementById('status-text');
        const tensionText = document.getElementById('tension-text');
        let hands;

        function onResults(results) {
            previewCanvas.width = video.videoWidth; previewCanvas.height = video.videoHeight;
            // Draw video to preview (No mirror in context, CSS mirrors the div)
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handState.detected = true;
                const lm = results.multiHandLandmarks[0];
                drawConnectors(previewCtx, lm, HAND_CONNECTIONS, {color: '#00d2ff', lineWidth: 4});

                // Tension Calc
                const d = Math.sqrt(Math.pow(lm[12].x-lm[0].x, 2) + Math.pow(lm[12].y-lm[0].y, 2));
                // Map: Open(0.4) -> 0.0. Closed(0.15) -> 1.0
                let rawT = 1 - ((d - 0.15)/0.25);
                rawT = Math.max(0, Math.min(1, rawT));
                
                handState.tension += (rawT - handState.tension) * 0.2;

                // Position (Mirrored Logic)
                handState.panX = (lm[9].x - 0.5); 
                handState.panY = (lm[9].y - 0.5);

                // Rotation
                handState.tiltZ = -Math.atan2(lm[9].x-lm[0].x, lm[9].y-lm[0].y);

                // UI
                statusText.innerText = "TRACKING ACTIVE";
                statusText.style.color = "#00d2ff";
                tensionText.innerText = Math.round(handState.tension * 100);

            } else {
                handState.detected = false;
                handState.tension *= 0.9; // Return to 0 (Assemble)
                statusText.innerText = "SEARCHING...";
                statusText.style.color = "#555";
            }
        }

        async function processVideo() {
            if(!video.paused) {
                await hands.send({image: video});
                requestAnimationFrame(processVideo);
            }
        }

        engageBtn.addEventListener('click', async () => {
            engageBtn.innerText = "CONNECTING...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } }
                });
                video.srcObject = stream;
                
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
                hands.onResults(onResults);
                
                video.onloadedmetadata = () => {
                    video.play();
                    processVideo();
                    // Show Preview, Hide Start Button
                    startContainer.style.display = 'none';
                    previewCard.style.display = 'block';
                };
            } catch(e) {
                alert("Camera Error: " + e.message);
                engageBtn.innerText = "RETRY";
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
