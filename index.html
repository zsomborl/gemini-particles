<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Visual Core | Rebuilt</title>
    <style>
        /* --- 1. THE VOID --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; touch-action: none; }
        
        /* --- 2. HUD INTERFACE --- */
        #hud {
            position: absolute; inset: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; z-index: 10;
        }

        /* Top Bar */
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }
        .stats-box { color: rgba(0, 210, 255, 0.6); font-size: 0.8rem; line-height: 1.5; text-shadow: 0 0 5px rgba(0,0,0,1); }
        .val { color: #fff; font-weight: bold; }
        .val.alert { color: #ff0055; text-shadow: 0 0 10px #ff0055; }

        /* Preview Window */
        #cam-preview {
            width: 120px; height: 160px; 
            background: #050505; border: 1px solid #333; 
            border-radius: 6px; overflow: hidden;
            transform: scaleX(-1); /* Mirror for natural feel */
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            opacity: 0; transition: opacity 0.5s;
        }
        #cam-canvas { width: 100%; height: 100%; object-fit: cover; }

        /* Center Start Button */
        #init-container {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            pointer-events: auto; text-align: center;
        }
        #init-btn {
            background: rgba(0, 210, 255, 0.1); border: 1px solid #00d2ff;
            color: #00d2ff; padding: 20px 50px; font-size: 1.2rem; letter-spacing: 4px;
            font-weight: bold; cursor: pointer; text-transform: uppercase;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.15); transition: 0.3s;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }
        #init-btn:hover { background: #00d2ff; color: #000; box-shadow: 0 0 60px rgba(0, 210, 255, 0.6); }

        /* Bottom Controls */
        #controls {
            display: flex; justify-content: center; gap: 10px; pointer-events: auto;
            opacity: 0.5; transition: opacity 0.3s;
        }
        #controls:hover { opacity: 1; }
        
        button.mode-btn {
            background: rgba(10,10,10,0.9); border: 1px solid #444; color: #888;
            padding: 12px 24px; border-radius: 2px; font-size: 0.75rem; font-weight: bold;
            cursor: pointer; text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s;
        }
        button.mode-btn.active { 
            border-color: #00d2ff; color: #fff; background: rgba(0, 210, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3); transform: translateY(-2px);
        }

        #video-hidden { display: none; }
    </style>
</head>
<body>

    <div id="webgl-container" style="position: absolute; inset: 0; z-index: 0;"></div>

    <div id="hud">
        <div class="hud-top">
            <div class="stats-box">
                CORE: <span id="ui-state" class="val">IDLE</span><br>
                ZOOM: <span id="ui-zoom" class="val">100</span>%<br>
                FPS: <span id="ui-fps" class="val">60</span>
            </div>
            <div id="cam-preview"><canvas id="cam-canvas"></canvas></div>
        </div>

        <div id="init-container">
            <button id="init-btn">ENGAGE SYSTEM</button>
            <div style="margin-top:15px; color:#555; font-size:0.7rem;">(VISUALIZATION ACTIVE)</div>
        </div>

        <div id="controls">
            <button class="mode-btn active" onclick="viz.setShape('jupiter')">Jupiter</button>
            <button class="mode-btn" onclick="viz.setShape('dna')">DNA Helix</button>
            <button class="mode-btn" onclick="viz.setShape('saturn')">Saturn</button>
            <button class="mode-btn" onclick="viz.setShape('galaxy')">Galaxy</button>
        </div>
    </div>

    <video id="video-hidden" playsinline webkit-playsinline muted autoplay></video>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>

    <script>
        /**
         * VISUALIZATION ENGINE (The Rebuild)
         * Handles all 3D rendering, Math, and Physics
         */
        class VisEngine {
            constructor() {
                this.isMobile = /Android|iPhone|iPad/i.test(navigator.userAgent);
                this.count = this.isMobile ? 5000 : 16000;
                this.clock = new THREE.Clock();
                this.container = document.getElementById('webgl-container');
                
                // State
                this.tension = 0.0; // 0 = Focused, 1 = Exploded
                this.targetTension = 0.0;
                
                // 6DoF Inputs
                this.rotInput = { x: 0, y: 0, z: 0 };
                
                this.initThree();
                this.initParticles();
                this.animate();
                
                // Start with Jupiter
                this.setShape('jupiter'); 
            }

            initThree() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.FogExp2(0x000000, 0.015);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 2000);
                this.camera.position.z = 40; // Base Zoom

                this.renderer = new THREE.WebGLRenderer({ antialias: !this.isMobile, alpha: true, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth/window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            initParticles() {
                const geo = new THREE.BufferGeometry();
                const pos = new Float32Array(this.count * 3);
                const col = new Float32Array(this.count * 3);
                
                // Custom Data Buffers
                this.targetPos = new Float32Array(this.count * 3); // Where shape is
                this.scatterPos = new Float32Array(this.count * 3); // Where explosion goes
                this.baseCol = new Float32Array(this.count * 3);   // Original color

                // Initialize Visible Sphere immediately
                for(let i=0; i<this.count; i++) {
                    const i3 = i*3;
                    
                    // Initial Layout: Random Sphere
                    const r = 15;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    
                    pos[i3] = r * Math.sin(phi) * Math.cos(theta);
                    pos[i3+1] = r * Math.sin(phi) * Math.sin(theta);
                    pos[i3+2] = r * Math.cos(phi);

                    // Scatter Targets (Far away)
                    const sr = 150 + Math.random() * 100;
                    this.scatterPos[i3] = sr * Math.sin(phi) * Math.cos(theta);
                    this.scatterPos[i3+1] = sr * Math.sin(phi) * Math.sin(theta);
                    this.scatterPos[i3+2] = sr * Math.cos(phi);

                    // Default White
                    col[i3] = 1; col[i3+1] = 1; col[i3+2] = 1;
                }

                geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
                geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

                // High-End Glow Texture
                const canvas = document.createElement('canvas'); canvas.width=32; canvas.height=32;
                const ctx = canvas.getContext('2d');
                const g = ctx.createRadialGradient(16,16,0,16,16,16);
                g.addColorStop(0, 'rgba(255,255,255,1)');
                g.addColorStop(0.4, 'rgba(255,255,255,0.2)');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle=g; ctx.fillRect(0,0,32,32);
                const tex = new THREE.Texture(canvas); tex.needsUpdate = true;

                const mat = new THREE.PointsMaterial({
                    size: this.isMobile ? 1.0 : 0.6,
                    map: tex,
                    vertexColors: true,
                    transparent: true,
                    opacity: 1.0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });

                this.particles = new THREE.Points(geo, mat);
                this.scene.add(this.particles);
            }

            // --- MATH GENERATORS ---
            setShape(type) {
                // UI Toggle
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                const btn = Array.from(document.querySelectorAll('.mode-btn')).find(b => b.innerText.toLowerCase().includes(type.split(' ')[0]));
                if(btn) btn.classList.add('active');

                let idx = 0;
                
                if (type === 'jupiter') {
                    for(let i=0; i<this.count; i++) {
                        const phi = Math.acos(-1 + (2*i)/this.count);
                        const theta = Math.sqrt(this.count*Math.PI)*phi;
                        const r = 14;
                        const x = r * Math.cos(theta) * Math.sin(phi);
                        const y = r * Math.sin(theta) * Math.sin(phi) * 0.9;
                        const z = r * Math.cos(phi);
                        
                        // Banding
                        const band = Math.sin(y*2.0 + Math.cos(x*0.3));
                        let rC=0.8, gC=0.7, bC=0.6;
                        if(band > 0.5) { rC=0.9; gC=0.8; bC=0.7; }
                        else if(band < -0.5) { rC=0.6; gC=0.4; bC=0.3; }
                        
                        // Red Spot
                        if(x>4 && x<9 && y>-5 && y<-2 && z>0) { rC=1.0; gC=0.2; bC=0.1; }
                        
                        this.setPoint(i, x,y,z, rC, gC, bC);
                    }
                } 
                else if (type === 'dna') {
                    // Precise Double Helix
                    const height = 60; const radius = 7; const turns = 4;
                    const steps = Math.floor(this.count / 16); // 16 particles per rung slice
                    
                    for(let i=0; i<steps; i++) {
                        const t = i/steps; 
                        const ang = t * Math.PI * 2 * turns;
                        const y = (t * height) - (height/2);
                        
                        // Strand 1 (Cyan)
                        this.setPoint(idx++, Math.cos(ang)*radius, y, Math.sin(ang)*radius, 0, 0.8, 1);
                        this.setPoint(idx++, Math.cos(ang)*radius+0.4, y, Math.sin(ang)*radius, 0, 1, 1); // Thickness
                        
                        // Strand 2 (Magenta - PI Offset)
                        this.setPoint(idx++, Math.cos(ang+Math.PI)*radius, y, Math.sin(ang+Math.PI)*radius, 1, 0, 0.5);
                        this.setPoint(idx++, Math.cos(ang+Math.PI)*radius+0.4, y, Math.sin(ang+Math.PI)*radius, 1, 0.2, 0.7);

                        // Rungs (Linear Interpolation between strands)
                        for(let k=0; k<12; k++) {
                            const lerp = k/12;
                            const rx = Math.cos(ang)*radius*(1-lerp) + Math.cos(ang+Math.PI)*radius*lerp;
                            const rz = Math.sin(ang)*radius*(1-lerp) + Math.sin(ang+Math.PI)*radius*lerp;
                            // Add jitter to rungs for energy look
                            this.setPoint(idx++, rx, y, rz, 0.5, 0.5, 0.8);
                        }
                    }
                    // Clean rest
                    for(let i=idx; i<this.count; i++) this.setPoint(i, 0,0,0, 0,0,0);
                }
                else if (type === 'saturn') {
                    const planetP = Math.floor(this.count * 0.4);
                    for(let i=0; i<this.count; i++) {
                        if(i < planetP) {
                            // Planet
                            const phi = Math.acos(-1 + (2*i)/planetP);
                            const theta = Math.sqrt(planetP*Math.PI)*phi;
                            const r = 9;
                            this.setPoint(i, 
                                r*Math.cos(theta)*Math.sin(phi), 
                                r*Math.sin(theta)*Math.sin(phi)*0.9, 
                                r*Math.cos(phi), 
                                0.9, 0.8, 0.6);
                        } else {
                            // Rings
                            const ang = Math.random() * Math.PI * 2;
                            const dist = 13 + Math.random() * 12;
                            this.setPoint(i,
                                Math.cos(ang)*dist,
                                (Math.random()-0.5)*0.4,
                                Math.sin(ang)*dist,
                                0.7, 0.7, 0.6);
                        }
                    }
                }
                else if (type === 'galaxy') {
                    for(let i=0; i<this.count; i++) {
                        const arms = 3;
                        const armOffset = (i % arms) * (Math.PI*2/arms);
                        const dist = Math.pow(Math.random(), 1.5) * 40; // Dense center
                        const ang = dist * 0.2 + armOffset;
                        
                        const centerFade = 1 - (dist/45);
                        
                        this.setPoint(i,
                            Math.cos(ang)*dist,
                            (Math.random()-0.5) * (5 - dist*0.1),
                            Math.sin(ang)*dist,
                            0.2 + centerFade*0.8, 0.1 + centerFade*0.5, 0.5 + centerFade*0.5
                        );
                    }
                }
            }

            setPoint(i, x, y, z, r, g, b) {
                if(i >= this.count) return;
                const i3 = i*3;
                this.targetPos[i3] = x; this.targetPos[i3+1] = y; this.targetPos[i3+2] = z;
                this.baseCol[i3] = r; this.baseCol[i3+1] = g; this.baseCol[i3+2] = b;
                
                // Force immediate update for instant visibility on load
                if(this.clock.getElapsedTime() < 1) {
                    const posAttr = this.particles.geometry.attributes.position.array;
                    const colAttr = this.particles.geometry.attributes.color.array;
                    posAttr[i3]=x; posAttr[i3+1]=y; posAttr[i3+2]=z;
                    colAttr[i3]=r; colAttr[i3+1]=g; colAttr[i3+2]=b;
                }
            }

            // --- ANIMATION LOOP ---
            animate() {
                requestAnimationFrame(this.animate.bind(this));
                
                const time = this.clock.getElapsedTime();
                const pos = this.particles.geometry.attributes.position.array;
                const col = this.particles.geometry.attributes.color.array;

                // Smooth Tension Transition
                this.tension += (this.targetTension - this.tension) * 0.1;

                // 1. SCENE MOVEMENT (Exaggerated & Mirrored)
                // Mirroring: Moving hand left (neg X) should rotate obj Left (neg Y)
                // Note: rotInput.x is already mapped to screen space (-1 to 1)
                const targetRotY = this.rotInput.x * -2.5; // Negative multiplier for mirror feel
                const targetRotX = this.rotInput.y * 2.5; 
                const targetRotZ = this.rotInput.z * 1.5;

                this.particles.rotation.y += (targetRotY - this.particles.rotation.y + time*0.05) * 0.1;
                this.particles.rotation.x += (targetRotX - this.particles.rotation.x) * 0.1;
                this.particles.rotation.z += (targetRotZ - this.particles.rotation.z) * 0.1;

                // 2. CAMERA ZOOM (Reaction)
                // Tension 0 (Open) = Zoom 40. Tension 1 (Closed) = Zoom 120 (Far)
                const targetZoom = 40 + (this.tension * 80);
                this.camera.position.z += (targetZoom - this.camera.position.z) * 0.1;

                // 3. PARTICLE PHYSICS
                // Use a non-linear curve for dispersion so it snaps at the end
                const mix = Math.pow(this.tension, 3);
                
                for(let i=0; i<this.count; i++) {
                    const i3 = i*3;
                    
                    // Lerp between Shape and Scatter
                    const tx = this.targetPos[i3] * (1-mix) + this.scatterPos[i3] * mix;
                    const ty = this.targetPos[i3+1] * (1-mix) + this.scatterPos[i3+1] * mix;
                    const tz = this.targetPos[i3+2] * (1-mix) + this.scatterPos[i3+2] * mix;

                    // Move
                    pos[i3] += (tx - pos[i3]) * 0.1;
                    pos[i3+1] += (ty - pos[i3+1]) * 0.1;
                    pos[i3+2] += (tz - pos[i3+2]) * 0.1;

                    // Color Reaction (Flash White on Disperse)
                    const flash = this.tension > 0.8 ? (this.tension-0.8)*2 : 0;
                    col[i3] = Math.min(1, this.baseCol[i3] + flash);
                    col[i3+1] = Math.min(1, this.baseCol[i3+1] + flash);
                    col[i3+2] = Math.min(1, this.baseCol[i3+2] + flash);
                }

                this.particles.geometry.attributes.position.needsUpdate = true;
                this.particles.geometry.attributes.color.needsUpdate = true;
                this.renderer.render(this.scene, this.camera);
                
                // Update FPS
                if(Math.random() > 0.95) document.getElementById('ui-fps').innerText = Math.round(1/this.clock.getDelta());
            }
        }

        // --- INIT VIZ ENGINE IMMEDIATELY ---
        const viz = new VisEngine();


        /**
         * TRACKING LOGIC
         * Handles Camera, AI, and Input Mapping
         */
        const initBtn = document.getElementById('init-btn');
        const video = document.getElementById('video-hidden');
        const camCanvas = document.getElementById('cam-canvas');
        const camCtx = camCanvas.getContext('2d');
        
        let hands;

        function onResults(results) {
            // Render Camera Feed to HUD
            camCanvas.width = video.videoWidth; camCanvas.height = video.videoHeight;
            camCtx.drawImage(results.image, 0, 0, camCanvas.width, camCanvas.height);

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                drawConnectors(camCtx, lm, HAND_CONNECTIONS, {color: '#00d2ff', lineWidth: 3});
                
                // 1. Calculate Tension (Open vs Closed)
                const wrist = lm[0]; const midTip = lm[12];
                const dist = Math.sqrt(Math.pow(midTip.x-wrist.x, 2) + Math.pow(midTip.y-wrist.y, 2));
                
                // Distance Mapping: Open (~0.4) -> 0.0 Tension. Closed (~0.15) -> 1.0 Tension
                // Clamped to ensure limits
                let t = 1 - ((dist - 0.15) / 0.25); 
                t = Math.max(0, Math.min(1, t));
                viz.targetTension = t;

                // 2. Calculate Rotation (Tilt)
                const dx = lm[9].x - lm[0].x;
                const dy = lm[9].y - lm[0].y;
                const rotZ = -Math.atan2(dx, dy);

                // 3. Calculate Pan (Position on Screen)
                // Center is 0.5. Range -0.5 to 0.5
                const panX = lm[9].x - 0.5;
                const panY = lm[9].y - 0.5;

                // Update Engine Inputs
                viz.rotInput = { x: panX, y: panY, z: rotZ };

                // HUD Updates
                const pct = Math.round(t*100);
                document.getElementById('ui-zoom').innerText = pct;
                
                const stateEl = document.getElementById('ui-state');
                if(pct > 80) { stateEl.innerText = "DISPERSING"; stateEl.className = "val alert"; }
                else if (pct < 20) { stateEl.innerText = "LOCKED"; stateEl.className = "val"; stateEl.style.color = "#00ff88"; }
                else { stateEl.innerText = "MORPHING"; stateEl.className = "val"; stateEl.style.color = "#fff"; }

            } else {
                // Lost Hand -> Reset
                viz.targetTension = 0; // Return to assembled
                document.getElementById('ui-state').innerText = "SCANNING";
            }
        }

        async function cameraLoop() {
            if(!video.paused) {
                await hands.send({image: video});
                requestAnimationFrame(cameraLoop);
            }
        }

        initBtn.addEventListener('click', async () => {
            initBtn.innerText = "CONNECTING...";
            initBtn.style.pointerEvents = "none";

            try {
                // 1. Force Permission Prompt
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: "user", width: { ideal: 480 }, height: { ideal: 640 } }
                });
                video.srcObject = stream;

                // 2. Load AI
                hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                hands.setOptions({
                    maxNumHands: 1, 
                    modelComplexity: viz.isMobile ? 0 : 1, 
                    minDetectionConfidence: 0.5, 
                    minTrackingConfidence: 0.5 
                });
                hands.onResults(onResults);

                // 3. Start
                video.onloadedmetadata = () => {
                    video.play();
                    cameraLoop();
                    
                    // UI Clean Up
                    document.getElementById('init-container').style.display = 'none';
                    document.getElementById('cam-preview').style.opacity = '1';
                };

            } catch (err) {
                alert("Camera Error: " + err.message);
                initBtn.innerText = "RETRY";
                initBtn.style.pointerEvents = "auto";
            }
        });
    </script>
</body>
</html>
